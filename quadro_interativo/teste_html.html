<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8">
  <title>Editor de Treliças</title>
  <style>
    body {
      font-family: Arial, Helvetica, sans-serif;
      margin: 12px;
      background: #0d1116;
      color: #dbdbdb;
    }
    #toolbar { margin-bottom: 8px; }
    button, select {
      margin-right: 6px;
      padding: 6px 10px;
      font-size: 14px;
    }
    #canvasWrap {
      border: 1px solid #bbb;
      display: inline-block;
      background: white;
    }
    canvas { display: block; }
    #info {
      display: inline-block;
      vertical-align: top;
      margin-left: 12px;
      width: 340px;
    }
    textarea { width: 100%; height: 220px; margin-top: 6px; font-family: monospace; }
    .small { font-size: 13px; color: #444; }
    .log { height: 120px; overflow-y: auto; background: #fff; border: 1px solid #ddd; padding: 6px; font-size: 13px; }
  </style>
</head>
<body>
  <h2>Editor de Treliças</h2>
  <div id="toolbar">
    <label>Modo:</label>
    <select id="mode">
      <option value="add">Adicionar Nó</option>
      <option value="connect">Conectar Nós</option>
      <option value="erase">Apagar Nó / Barra</option>
    </select>
    <button id="exportBtn">Exportar .txt</button>
    <button id="clearBtn">Limpar</button>
    <button id="undoBtn">Desfazer</button>
    <span class="small">(snap: 1 unidade = 1 grid | botão direito edita vínculos e forças)</span>
  </div>

  <div>
    <div id="canvasWrap">
      <canvas id="gridCanvas" width="720" height="480" style="width:720px;height:480px;"></canvas>
    </div>
    <div id="info">
      <h4>Nós</h4>
      <div id="nodesList" class="small"></div>

      <h4>Barras</h4>
      <div id="barsList" class="small"></div>

      <h4>Log</h4>
      <div class="log" id="log"></div>

      <h4>Conteúdo do .txt</h4>
      <textarea id="txtOut" readonly></textarea>
    </div>
  </div>

<script>
  const canvas = document.getElementById('gridCanvas');
  const ctx = canvas.getContext('2d');
  const spacing = 24;
  const radius = 7;
  const modeSelect = document.getElementById('mode');
  const exportBtn = document.getElementById('exportBtn');
  const clearBtn = document.getElementById('clearBtn');
  const undoBtn = document.getElementById('undoBtn');
  const nodesListDiv = document.getElementById('nodesList');
  const barsListDiv = document.getElementById('barsList');
  const logDiv = document.getElementById('log');
  const txtOut = document.getElementById('txtOut');

  function fixDPI() {
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.round(rect.width * dpr);
    canvas.height = Math.round(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  fixDPI();
  window.addEventListener('resize', () => { fixDPI(); redraw(); });

  let nodes = []; // {id, name, gx, gy, xPx, yPx, vinculo, forca:{px,py}}
  let bars = [];
  let selected = [];
  let history = [];

  function makeName(index) {
    let s = "";
    while (index > 0) {
      let rem = (index - 1) % 26;
      s = String.fromCharCode(65 + rem) + s;
      index = Math.floor((index - 1) / 26);
    }
    return s;
  }
  function log(msg) {
    const p = document.createElement('div');
    p.textContent = msg;
    logDiv.appendChild(p);
    logDiv.scrollTop = logDiv.scrollHeight;
  }
  function snapshot() {
    history.push(JSON.parse(JSON.stringify({nodes, bars})));
    if (history.length > 50) history.shift();
  }
  function undo() {
    if (history.length === 0) return;
    const state = history.pop();
    nodes = state.nodes;
    bars = state.bars;
    selected = [];
    redraw();
    refreshPanels();
    log('Desfeito');
  }

  function clearCanvas() { ctx.clearRect(0, 0, canvas.width, canvas.height); }
  function drawGrid() {
    const rect = canvas.getBoundingClientRect();
    const w = rect.width, h = rect.height;
    ctx.save();
    ctx.fillStyle = '#fafafa';
    ctx.fillRect(0,0,w,h);
    ctx.strokeStyle = '#e0e0e0';
    for (let x = 0; x <= w; x += spacing) {
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
    }
    for (let y = 0; y <= h; y += spacing) {
      ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
    }
    ctx.restore();
  }
  function drawBars() {
    ctx.save();
    ctx.lineWidth = 3;
    ctx.strokeStyle = '#2b7cff';
    bars.forEach(b => {
      const n1 = nodes.find(n => n.id === b.n1);
      const n2 = nodes.find(n => n.id === b.n2);
      if (!n1 || !n2) return;
      ctx.beginPath();
      ctx.moveTo(n1.xPx, n1.yPx);
      ctx.lineTo(n2.xPx, n2.yPx);
      ctx.stroke();
    });
    ctx.restore();
  }
  function drawNodes() {
    nodes.forEach(n => {
      ctx.beginPath();
      ctx.arc(n.xPx, n.yPx, radius, 0, Math.PI * 2);
      ctx.fillStyle = '#e33';
      ctx.fill();
      ctx.strokeStyle = '#000';
      ctx.stroke();
      ctx.fillStyle = '#000';
      ctx.fillText(n.name, n.xPx + 10, n.yPx - 8);
      if (n.forca && (n.forca.px !== 0 || n.forca.py !== 0)) {
        ctx.fillStyle = "red";
        ctx.fillText(`F(${n.forca.px},${n.forca.py})`, n.xPx + 10, n.yPx + 10);
      }
      if (n.vinculo && n.vinculo !== "N") {
        ctx.fillStyle = "green";
        ctx.fillText(n.vinculo, n.xPx - 20, n.yPx + 20);
      }
    });
  }
  function redraw() { clearCanvas(); drawGrid(); drawBars(); drawNodes(); }

  function findNodeAt(px, py) {
    return nodes.find(n => Math.hypot(n.xPx - px, n.yPx - py) <= radius + 6);
  }
  function findBarAt(px, py) {
    for (let b of bars) {
      const a = nodes.find(n => n.id === b.n1);
      const c = nodes.find(n => n.id === b.n2);
      if (!a || !c) continue;
      const dist = pointToSegmentDistance(px, py, a.xPx, a.yPx, c.xPx, c.yPx);
      if (dist < 6) return b;
    }
    return null;
  }
  function pointToSegmentDistance(px,py,x1,y1,x2,y2){
    const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
    const dot = A * C + B * D;
    const len_sq = C * C + D * D;
    let param = len_sq !== 0 ? dot / len_sq : -1;
    let xx, yy;
    if (param < 0) { xx = x1; yy = y1; }
    else if (param > 1) { xx = x2; yy = y2; }
    else { xx = x1 + param * C; yy = y1 + param * D; }
    return Math.hypot(px - xx, py - yy);
  }

  canvas.addEventListener('click', ev => {
    const rect = canvas.getBoundingClientRect();
    const px = ev.clientX - rect.left;
    const py = ev.clientY - rect.top;
    const snappedX = Math.round(px / spacing) * spacing;
    const snappedY = Math.round(py / spacing) * spacing;
    const mode = modeSelect.value;

    if (mode === 'add') {
      if (nodes.some(n => n.xPx === snappedX && n.yPx === snappedY)) {
        log('Já existe nó nesse ponto.'); return;
      }
      snapshot();
      const id = nodes.length + 1;
      const name = makeName(id);
      nodes.push({id, name, gx: snappedX/spacing, gy: snappedY/spacing, xPx: snappedX, yPx: snappedY, vinculo:"N", forca:{px:0,py:0}});
      log(`Nó ${name} adicionado.`);
      redraw(); refreshPanels();
    }
    if (mode === 'connect') {
      const node = findNodeAt(px, py);
      if (!node) { log("Clique em um nó válido."); return; }
      selected.push(node.id);
      if (selected.length === 2) {
        const [a,b] = selected;
        if (a!==b && !bars.some(bb=>(bb.n1===a&&bb.n2===b)||(bb.n1===b&&bb.n2===a))) {
          snapshot(); bars.push({id: bars.length+1, n1:a, n2:b});
          log(`Barra entre ${makeName(a)} e ${makeName(b)} criada.`);
        }
        selected=[];
        redraw(); refreshPanels();
      }
    }
    if (mode === 'erase') {
      const b = findBarAt(px, py);
      if (b) { snapshot(); bars = bars.filter(bb=>bb.id!==b.id); redraw(); refreshPanels(); return; }
      const n = findNodeAt(px, py);
      if (n) { snapshot(); nodes = nodes.filter(nn=>nn.id!==n.id); bars = bars.filter(bb=>bb.n1!==n.id&&bb.n2!==n.id);
        log(`Nó ${n.name} removido.`); redraw(); refreshPanels(); return;}
    }
  });

  // Clique direito para editar vínculo e força
  canvas.addEventListener("contextmenu", e => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left, y = e.clientY - rect.top;
    let node = findNodeAt(x, y);
    if (node) {
      let vinc = prompt("Digite o vínculo (N, P, X, Y):", node.vinculo);
      if (["N","P","X","Y"].includes(vinc)) node.vinculo = vinc;
      let px = parseFloat(prompt("Força Fx:", node.forca.px));
      let py = parseFloat(prompt("Força Fy:", node.forca.py));
      node.forca = {px:isNaN(px)?0:px, py:isNaN(py)?0:py};
      redraw(); refreshPanels();
    }
  });

  function refreshPanels() {
    nodesListDiv.innerHTML = nodes.map(n => `${n.name} (${n.gx},${n.gy}) F=(${n.forca.px},${n.forca.py}) Vinc=${n.vinculo}`).join("<br>");
    barsListDiv.innerHTML = bars.map(b => `${b.id}: ${makeName(b.n1)}-${makeName(b.n2)}`).join("<br>");
    txtOut.value = buildTxtString();
  }

  function buildTxtString() {
    const n=nodes.length, m=bars.length;
    let lines=[`${n}; ${m}`];
    nodes.forEach(nd=>lines.push(`${nd.name}; ${nd.gx}; ${-nd.gy}`));
    const mat=Array.from({length:n},()=>Array(n).fill(0));
    bars.forEach(b=>{mat[b.n1-1][b.n2-1]=1;mat[b.n2-1][b.n1-1]=1;});
    mat.forEach(r=>lines.push(r.join("; ")));
    nodes.forEach(no=>lines.push(`${no.forca.px}; ${no.forca.py}`));
    nodes.forEach(no=>lines.push(no.vinculo));
    return lines.join("\n");
  }

  function exportTXT() {
    const content=buildTxtString();
    const blob=new Blob([content],{type:"text/plain"});
    const url=URL.createObjectURL(blob);
    const a=document.createElement("a");a.href=url;a.download="trelica.txt";a.click();
    URL.revokeObjectURL(url);
    log("Exportado trelica.txt");
  }

  exportBtn.addEventListener("click",exportTXT);
  clearBtn.addEventListener("click",()=>{snapshot();nodes=[];bars=[];selected=[];redraw();refreshPanels();});
  undoBtn.addEventListener("click",undo);

  redraw(); refreshPanels(); log("Editor pronto.");
</script>
</body>
</html>
